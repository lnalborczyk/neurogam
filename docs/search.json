[{"path":"https://lnalborczyk.github.io/neurogam/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 neurogam authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_spatio_temporal.html","id":"importing-and-visualising-eeg-data","dir":"Articles","previous_headings":"","what":"Importing and visualising EEG data","title":"Application to spatio-temporal EEG data (in progress)","text":"import reshape EEG data eegkit package.  visualise sensors grid using plot_sensors() function.  visualise average EEG topography time using plot_eeg() function.","code":"library(neurogam) library(ggplot2) library(eegkit) library(dplyr)  # retrieving some EEG data data(eegdata) head(eegdata) #>       subject group condition trial channel time voltage #> 1 co2a0000364     a        S1     0     FP1    0  -8.921 #> 2 co2a0000364     a        S1     0     FP1    1  -8.433 #> 3 co2a0000364     a        S1     0     FP1    2  -2.574 #> 4 co2a0000364     a        S1     0     FP1    3   5.239 #> 5 co2a0000364     a        S1     0     FP1    4  11.587 #> 6 co2a0000364     a        S1     0     FP1    5  14.028  # plotting the average ERP per group and channel eegdata |>     summarise(voltage = mean(voltage), .by = c(group, channel, time) ) |>     ggplot(aes(x = time, y = voltage, colour = group) ) +     geom_line() +     facet_wrap(~channel) +     theme_bw() # retrieving sensors x and y coordinates data(eegcoord) enames <- rownames(eegcoord)  # merging the data eeg_coords <- eegcoord |>     mutate(channel = enames) |>     select(channel, xproj, yproj)  # summarising the data eeg_data <- eegdata |>     summarise(voltage = mean(voltage), .by = c(subject, channel, time) ) |>     left_join(eeg_coords, by = \"channel\") |>     # converting timesteps to seconds     mutate(time = (time + 1) / 256) |>     # rounding numeric variables     mutate(across(is.numeric, ~round(.x, 4) ) ) |>     # removing NAs     na.omit() |>     # scaling the variables before fitting     mutate(         xproj = xproj / sd(xproj),         yproj = yproj / sd(yproj),         voltage = voltage / sd(voltage)         )  # sensors: one row per channel with columns xproj, yproj sensors <- unique(eeg_data[, c(\"channel\", \"xproj\", \"yproj\")])  # show a few rows head(sensors) #>      channel      xproj     yproj #> 1        FP1 -0.6712590 1.8012175 #> 257      FP2  0.6721339 1.7996850 #> 513       F7 -1.4744817 0.9956874 #> 769       F8  1.4718131 0.9941358 #> 1025     AF1 -0.3442040 1.4196194 #> 1281     AF2  0.3450789 1.4182019 # plotting the sensors grid plot_sensors(     sensors,     show_points = TRUE,     show_labels = TRUE,     label_col = \"channel\",     label_repel = FALSE,     highlight = c(\"C1\", \"CZ\", \"C2\"),     label_only_highlight = FALSE,     dim_others = TRUE,     head_expand = 1.1     ) # retrieving the first 100 unique timesteps time_steps <- unique(eeg_data$time)[1:100]  # taking 8 equally spaced timesteps time_steps_discrete <- st_take_n_times(time_vec = time_steps, N = 8)  # averaging EEG data per channel and timestep eeg_data_summary <- eeg_data %>%     summarise(voltage = mean(voltage), .by = c(channel, time, xproj, yproj) ) |>     dplyr::filter(time %in% time_steps_discrete)  # topoplot of summary data plot_eeg(     x = eeg_data_summary,     type = \"topo\",     sensors = sensors,     times = time_steps_discrete,     grid_res = 200,     value_col = \"voltage\",     facet_nrow = 2,     fill_limits = \"global_quantile\"     )"},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_spatio_temporal.html","id":"spatio-temporal-modelling-with-bgams","dir":"Articles","previous_headings":"","what":"Spatio-temporal modelling with BGAMs","title":"Application to spatio-temporal EEG data (in progress)","text":"progress…","code":""},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_temporal.html","id":"importing-and-visualising-eeg-data","dir":"Articles","previous_headings":"","what":"Importing and visualising EEG data","title":"Application to 1D temporal EEG data","text":"import reshape EEG data eegkit package.","code":"library(neurogam) library(ggplot2) library(eegkit) library(dplyr)  # retrieving some EEG data data(eegdata) head(eegdata) #>       subject group condition trial channel time voltage #> 1 co2a0000364     a        S1     0     FP1    0  -8.921 #> 2 co2a0000364     a        S1     0     FP1    1  -8.433 #> 3 co2a0000364     a        S1     0     FP1    2  -2.574 #> 4 co2a0000364     a        S1     0     FP1    3   5.239 #> 5 co2a0000364     a        S1     0     FP1    4  11.587 #> 6 co2a0000364     a        S1     0     FP1    5  14.028  # plotting the average ERP per group and channel eegdata |>     summarise(voltage = mean(voltage), .by = c(group, channel, time) ) |>     ggplot(aes(x = time, y = voltage, colour = group) ) +     geom_line() +     facet_wrap(~channel) +     theme_bw() # reshape the data eeg_data <- eegdata |>     # keeping only one channel     dplyr::filter(channel == \"PZ\") |>     # converting timesteps to seconds     mutate(time = (time + 1) / 256) |>     # rounding numeric variables     mutate(across(is.numeric, ~round(.x, 4) ) ) |>     # removing NAs     na.omit()  # show a few rows head(eeg_data) #>       subject group condition trial channel   time voltage #> 1 co2a0000364     a        S1     0      PZ 0.0039  -2.797 #> 2 co2a0000364     a        S1     0      PZ 0.0078  -4.262 #> 3 co2a0000364     a        S1     0      PZ 0.0117  -4.262 #> 4 co2a0000364     a        S1     0      PZ 0.0156  -2.797 #> 5 co2a0000364     a        S1     0      PZ 0.0195  -0.844 #> 6 co2a0000364     a        S1     0      PZ 0.0234   0.132"},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_temporal.html","id":"fitting-the-model","dir":"Articles","previous_headings":"","what":"Fitting the model","title":"Application to 1D temporal EEG data","text":"Figure 1 fit new model, specifying predictor_id = NA (group varies across participants) by_ppt = TRUE return clusters participant level. Figure 2 recommend visually assessing predictions model observed data (participant). provide lightweight ppc() method, can conduct various PPCs brms::pp_check(results$model, ...) (available PPCs, see https://mc-stan.org/bayesplot/reference/PPC-overview.html). Figure 3 Figure 4","code":"# fitting the BGAMM to identify clusters (around 20-30 min on a recent laptop) results <- testing_through_time(     # EEG data     data = eeg_data,     # participant column     participant_id = \"subject\",     # EEG column     outcome_id = \"voltage\",     # name of predictor in data     predictor_id = \"group\",     # basis dimension     kvalue = 30,     # we recommend fitting the GAMM with summary statistics (mean and SD)     multilevel = \"summary\",     # threshold on posterior odds     threshold = 10,     # number of MCMCs     chains = 4,     # number of parallel cores     cores = 4     ) # displaying the identified clusters print(results) #>  #> ==== Time-resolved GAMM results =============================== #>  #> Clusters found:  #>  #>  cluster_id cluster_onset cluster_offset duration #>           1          0.27          0.438    0.168 #>  #> ================================================================= # plotting the data, model's predictions, and clusters plot(results) # fitting the BGAMM to identify clusters (around 20-30 min on 4 laptop apple M4 cores) results <- testing_through_time(     # EEG data     data = eeg_data,     # participant column     participant_id = \"subject\",     # EEG column     outcome_id = \"voltage\",     # here we use no predictor (because group varies across participants)     predictor_id = NA,     # basis dimension (for both the group and participant levels)     kvalue = 30,     # we recommend fitting the GAMM with summary statistics (mean and SD)     multilevel = \"summary\",     # return clusters at both the group and participant levels     by_ppt = TRUE,     # threshold on posterior odds     threshold = 10,     # number of MCMCs     chains = 4,     # number of parallel cores     cores = 4     ) # displaying the identified clusters print(results) #>  #> ==== Time-resolved GAMM results =============================== #>  #> Clusters found:  #>  #>  participant cluster_id cluster_onset cluster_offset duration #>  co2a0000364          1         0.336          0.398    0.062 #>  co2a0000369          1         0.191          0.394    0.203 #>  co2a0000370          1         0.059          0.148    0.089 #>  co2a0000370          2         0.211          0.473    0.262 #>  co2a0000370          3         0.566          0.660    0.094 #>  co2a0000370          4         0.773          0.887    0.114 #>  co2a0000372          1         0.004          0.023    0.019 #>  co2a0000372          2         0.066          0.152    0.086 #>  co2a0000372          3         0.301          1.000    0.699 #>  co2a0000375          1         0.004          0.445    0.441 #>  co2a0000375          2         0.856          0.957    0.101 #>  co2a0000377          1         0.004          0.031    0.027 #>  co2a0000377          2         0.113          0.148    0.035 #>  co2a0000377          3         0.219          0.258    0.039 #>  co2a0000377          4         0.344          0.469    0.125 #>  co2a0000378          1         0.219          0.516    0.297 #>  co2c0000337          1         0.086          0.109    0.023 #>  co2c0000337          2         0.305          0.500    0.195 #>  co2c0000340          1         0.039          0.059    0.020 #>  co2c0000341          1         0.227          0.676    0.449 #>  co2c0000342          1         0.004          0.156    0.152 #>  co2c0000342          2         0.180          1.000    0.820 #>  co2c0000344          1         0.238          0.254    0.016 #>  co2c0000344          2         0.305          0.356    0.051 #>  co2c0000345          1         0.004          0.086    0.082 #>  co2c0000345          2         0.281          0.402    0.121 #>  co2c0000345          3         0.629          0.676    0.047 #>  co2c0000346          1         0.004          0.156    0.152 #>  co2c0000346          2         0.188          0.461    0.273 #>  co2c0000347          1         0.004          0.137    0.133 #>  co2c0000347          2         0.211          0.449    0.238 #>  #> ================================================================= # plotting the data, model's predictions, and clusters plot(results) # posterior predictive checks (PPCs) at the group level ppc(object = results, ppc_type = \"group\") # posterior predictive checks (PPCs) at the participant level ppc(object = results, ppc_type = \"participant\")"},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_temporal.html","id":"visualising-the-results","dir":"Articles","previous_headings":"","what":"Visualising the results","title":"Application to 1D temporal EEG data","text":"Figure 1","code":"# displaying the identified clusters print(results) #>  #> ==== Time-resolved GAMM results =============================== #>  #> Clusters found:  #>  #>  cluster_id cluster_onset cluster_offset duration #>           1          0.27          0.438    0.168 #>  #> ================================================================= # plotting the data, model's predictions, and clusters plot(results)"},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_temporal.html","id":"computing-clusters-at-the-participant-level","dir":"Articles","previous_headings":"","what":"Computing clusters at the participant-level","title":"Application to 1D temporal EEG data","text":"fit new model, specifying predictor_id = NA (group varies across participants) by_ppt = TRUE return clusters participant level.","code":"# fitting the BGAMM to identify clusters (around 20-30 min on 4 laptop apple M4 cores) results <- testing_through_time(     # EEG data     data = eeg_data,     # participant column     participant_id = \"subject\",     # EEG column     outcome_id = \"voltage\",     # here we use no predictor (because group varies across participants)     predictor_id = NA,     # basis dimension (for both the group and participant levels)     kvalue = 30,     # we recommend fitting the GAMM with summary statistics (mean and SD)     multilevel = \"summary\",     # return clusters at both the group and participant levels     by_ppt = TRUE,     # threshold on posterior odds     threshold = 10,     # number of MCMCs     chains = 4,     # number of parallel cores     cores = 4     )"},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_temporal.html","id":"visualising-the-results-1","dir":"Articles","previous_headings":"","what":"Visualising the results","title":"Application to 1D temporal EEG data","text":"Figure 2","code":"# displaying the identified clusters print(results) #>  #> ==== Time-resolved GAMM results =============================== #>  #> Clusters found:  #>  #>  participant cluster_id cluster_onset cluster_offset duration #>  co2a0000364          1         0.336          0.398    0.062 #>  co2a0000369          1         0.191          0.394    0.203 #>  co2a0000370          1         0.059          0.148    0.089 #>  co2a0000370          2         0.211          0.473    0.262 #>  co2a0000370          3         0.566          0.660    0.094 #>  co2a0000370          4         0.773          0.887    0.114 #>  co2a0000372          1         0.004          0.023    0.019 #>  co2a0000372          2         0.066          0.152    0.086 #>  co2a0000372          3         0.301          1.000    0.699 #>  co2a0000375          1         0.004          0.445    0.441 #>  co2a0000375          2         0.856          0.957    0.101 #>  co2a0000377          1         0.004          0.031    0.027 #>  co2a0000377          2         0.113          0.148    0.035 #>  co2a0000377          3         0.219          0.258    0.039 #>  co2a0000377          4         0.344          0.469    0.125 #>  co2a0000378          1         0.219          0.516    0.297 #>  co2c0000337          1         0.086          0.109    0.023 #>  co2c0000337          2         0.305          0.500    0.195 #>  co2c0000340          1         0.039          0.059    0.020 #>  co2c0000341          1         0.227          0.676    0.449 #>  co2c0000342          1         0.004          0.156    0.152 #>  co2c0000342          2         0.180          1.000    0.820 #>  co2c0000344          1         0.238          0.254    0.016 #>  co2c0000344          2         0.305          0.356    0.051 #>  co2c0000345          1         0.004          0.086    0.082 #>  co2c0000345          2         0.281          0.402    0.121 #>  co2c0000345          3         0.629          0.676    0.047 #>  co2c0000346          1         0.004          0.156    0.152 #>  co2c0000346          2         0.188          0.461    0.273 #>  co2c0000347          1         0.004          0.137    0.133 #>  co2c0000347          2         0.211          0.449    0.238 #>  #> ================================================================= # plotting the data, model's predictions, and clusters plot(results)"},{"path":"https://lnalborczyk.github.io/neurogam/articles/eeg_temporal.html","id":"posterior-predictive-checks","dir":"Articles","previous_headings":"","what":"Posterior predictive checks","title":"Application to 1D temporal EEG data","text":"recommend visually assessing predictions model observed data (participant). provide lightweight ppc() method, can conduct various PPCs brms::pp_check(results$model, ...) (available PPCs, see https://mc-stan.org/bayesplot/reference/PPC-overview.html). Figure 3 Figure 4","code":"# posterior predictive checks (PPCs) at the group level ppc(object = results, ppc_type = \"group\") # posterior predictive checks (PPCs) at the participant level ppc(object = results, ppc_type = \"participant\")"},{"path":"https://lnalborczyk.github.io/neurogam/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ladislas Nalborczyk. Author, maintainer. Paul Bürkner. Contributor.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Nalborczyk L, Bürkner P (2025). “Precise temporal localisation M/EEG effects Bayesian generalised additive multilevel models.” bioRxiv. doi:10.1101/2025.08.29.672336.","code":"@Article{,   title = {Precise temporal localisation of M/EEG effects with Bayesian generalised additive multilevel models},   author = {Ladislas Nalborczyk and Paul Bürkner},   year = {2025},   journal = {bioRxiv},   doi = {10.1101/2025.08.29.672336}, }"},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"modelling-time-resolved-electrophysiological-data-with-bayesian-generalised-additive-multilevel-models-","dir":"","previous_headings":"","what":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"goal neurogam provide utilities estimating onset offset time-resolved effects, found M/EEG, pupillometry, finger/mouse-tracking data (amongst others). current version allows fitting 1D temporal data (e.g., raw M/EEG data decoding timecourses) extended near future support 2D temporal spatiotemporal data.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"can install development version neurogam GitHub :","code":"install.packages(\"remotes\")  remotes::install_github(     repo = \"https://github.com/lnalborczyk/neurogam\",     dependencies = TRUE     )"},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"model-fitting","dir":"","previous_headings":"Usage","what":"Model fitting","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"fit Bayesian generalised additive multilevel model (BGAMM) varying intercept, slope, smooth (per participant) estimate onset offset difference conditions. Note recommend fitting BGAMM time-resolved summary statistics (mean SD) full (.e., trial--trial) BGAMM may slow, group-level BGAM (.e., random/varying effect) may provide liberal cluster estimates.","code":"# loading the neurogam package library(neurogam)  # importing some simulated EEG data data(eeg_data)  # displaying some rows head(eeg_data) #>      participant condition trial  time       eeg #> 1 participant_01     cond1     1 0.000 0.8618045 #> 2 participant_01     cond1     1 0.002 1.2729148 #> 3 participant_01     cond1     1 0.004 1.6538158 #> 4 participant_01     cond1     1 0.006 1.3910888 #> 5 participant_01     cond1     1 0.008 0.6499553 #> 6 participant_01     cond1     1 0.010 0.1548358 # fitting the BGAMM to identify clusters (around 10 minutes on a recent laptop) results <- testing_through_time(     # simulated EEG data     data = eeg_data,     # name of predictor in data     # predictor_id = \"condition\",     # when predictor_id = NA, tests average level against 0     predictor_id = NA,     # we recommend fitting the GAMM with summary statistics (mean and SD)     multilevel = \"summary\",     # threshold on posterior odds     threshold = 10,     # number of iterations (per MCMC)     iter = 5000     )"},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"visualising-the-results","dir":"","previous_headings":"Usage","what":"Visualising the results","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"","code":"# displaying the identified clusters print(results) #>  #> ==== Time-resolved GAMM results =============================== #>  #> Clusters found:  #>  #>  cluster_id cluster_onset cluster_offset duration #>           1         0.162          0.348    0.186 #>  #> ================================================================= # plotting the data, model's predictions, and clusters plot(results)"},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"posterior-predictive-checks","dir":"","previous_headings":"Usage","what":"Posterior predictive checks","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"recommend visually assessing predictions model observed data. provide lightweight ppc() method, can conduct various PPCs brms::pp_check(results$model, ...) (available PPCs, see https://mc-stan.org/bayesplot/reference/PPC-overview.html).","code":"# posterior predictive checks (PPCs) ppc(object = results, ppc_type = \"participant\")"},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"how-to-define-the-basis-dimension","dir":"","previous_headings":"Usage","what":"How to define the basis dimension?","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"provide single universal recommendation choosing optimal value kk, depends several factors, including sampling rate, preprocessing steps (e.g., signal--noise ratio, low-pass filtering), underlying temporal dynamics effect interest. One strategy set kk high computational constraints allow (acknowledging kk-value provides upper bound effective basis dimension). Alternatively, one can fit series models different kk values compare models using information criteria LOOIC WAIC, alongside posterior predictive checks (PPCs), select model best captures structure data. illustrate approach .","code":"# recommend an optimal smooth basis dimension k k_res <- recommend_k(     object = results,     k_min = 10,     k_max = 40,     k_step = 5,     criterion = \"waic\"     ) # results summary summary(k_res) #>  #> ==== Summary of k recommendation =================================== #>  #> Number of models fitted  : 7 #> k values tested          : 10, 15, 20, 25, 30, 35, 40 #> Range of k values        : [10, 40] #> Knee based on            : p_waic #> Recommended k (knee)     : 20 #>  #> Comparison table (rounded): #>  #>   k   model waic_elpd waic_elpd_se p_waic p_waic_se     waic p_waic_smooth #>  10 gam_k10 -4703.605        5.394  0.145     0.003 9407.211         0.145 #>  15 gam_k15 -4703.905        5.395  0.154     0.003 9407.809         0.154 #>  20 gam_k20 -4704.028        5.395  0.156     0.003 9408.056         0.156 #>  25 gam_k25 -4704.070        5.395  0.157     0.003 9408.140         0.157 #>  30 gam_k30 -4704.071        5.395  0.157     0.003 9408.141         0.157 #>  40 gam_k40 -4704.118        5.395  0.158     0.003 9408.236         0.158 #>  35 gam_k35 -4704.143        5.395  0.158     0.003 9408.286         0.158 #>  #> ===================================================================="},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"polyglot-use-of-neurogam","dir":"","previous_headings":"","what":"Polyglot use of neurogam","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"use neurogam functions Python (e.g., MNE epochs), recommend using rpy2 interface (https://github.com/rpy2/rpy2), shown . simply requires reshaping MNE epochs long format (one trial/observation per row) (see instance epochs.to_data_frame(long_format=True), https://mne.tools/stable/generated/mne.Epochs.html#mne.Epochs.to_data_frame). use neurogam functions Julia (e.g., MNE epochs), recommend using RCall package (https://juliainterop.github.io/RCall.jl/stable/) (thanks Benedikt Ehinger sharing code snippet).","code":"# loading the Python modules import rpy2.robjects as robjects from rpy2.robjects.packages import importr from rpy2.robjects.conversion import localconverter  # importing the \"neurogam\" R package neurogam = importr(\"neurogam\")  # reshaping epochs into long format # long_df = epochs.to_data_frame(long_format=True)  # assuming long_df is some M/EEG data reshaped in long format with localconverter(robjects.default_converter + pandas2ri.converter):          long_df_r = robjects.conversion.py2rpy(long_df)       # using the testing_through_time() function from the neurogam package results = neurogam.testing_through_time(data=long_df_r, threshold=10) # loading the RCall module using RCall  # importing the neurogam R package @rimport neurogam  # assuming long_df is some M/EEG data reshaped in long format results = neurogam.testing_through_time(data=long_df, threshold=10)"},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"using neurogam, please cite following publication: Nalborczyk, L., & Bürkner, P. (2025). Precise temporal localisation M/EEG effects Bayesian generalised additive multilevel models. biorXiv. Preprint available : https://doi.org/10.1101/2025.08.29.672336. neurogam interface brms package, please additionally cite one following publications: Bürkner P. C. (2017). brms: R Package Bayesian Multilevel Models using Stan. Journal Statistical Software. 80(1), 1-28. doi.org/10.18637/jss.v080.i01 Bürkner P. C. (2018). Advanced Bayesian Multilevel Modeling R Package brms. R Journal. 10(1), 395-411. doi.org/10.32614/RJ-2018-017 Bürkner P. C. (2021). Bayesian Item Response Modeling R brms Stan. Journal Statistical Software, 100(5), 1-54. doi.org/10.18637/jss.v100.i05","code":""},{"path":"https://lnalborczyk.github.io/neurogam/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Modelling time-resolved electrophysiological data with Bayesian generalised additive multilevel models","text":"encounter bug question please file issue minimal reproducible example GitHub.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/check_within_between.html","id":null,"dir":"Reference","previous_headings":"","what":"Test whether a predictor varies (or not) per participant — check_within_between","title":"Test whether a predictor varies (or not) per participant — check_within_between","text":"Test whether predictor varies () per participant","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/check_within_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test whether a predictor varies (or not) per participant — check_within_between","text":"","code":"check_within_between(   data,   participant,   predictor,   tol = 0,   min_within_prop = 0.9 )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/eeg_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated EEG data — eeg_data","title":"Simulated EEG data — eeg_data","text":"Simulated EEG data.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/eeg_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated EEG data — eeg_data","text":"","code":"eeg_data"},{"path":"https://lnalborczyk.github.io/neurogam/reference/eeg_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated EEG data — eeg_data","text":"data frame 502000 rows 5 variables: participant Character variable indicating participant's ID. condition Integer variable indicating condition. trial Integer variable indicating trial number. time Numeric variable indicating time step (seconds). eeg Numeric variable indicating EEG signal.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/find_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Find contiguous clusters in a time series — find_clusters","title":"Find contiguous clusters in a time series — find_clusters","text":"Identify contiguous clusters time points time series variable exceeds positive threshold falls negative threshold. Clusters defined consecutive time points satisfying thresholding condition.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/find_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find contiguous clusters in a time series — find_clusters","text":"","code":"find_clusters(   data,   threshold = 10,   group = NULL,   above_threshold = TRUE,   both_signs = TRUE )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/find_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find contiguous clusters in a time series — find_clusters","text":"data data frame containing least two columns named \"time\" \"value\". group NULL, data must also contain grouping column. threshold Numeric scalar specifying (positive) threshold used define clusters. Positive clusters defined value >= threshold, negative clusters value <= -threshold. Must non-negative both_signs = TRUE. group Optional grouping column name (character scalar) used find clusters independently within group level (e.g., \"participant\"). Set NULL (default) ignore grouping. above_threshold Logical scalar used both_signs = FALSE. TRUE (default), clusters formed value >= threshold; FALSE, clusters formed value <= threshold. both_signs Logical scalar indicating whether detect positive negative clusters single call (default: TRUE). TRUE, above_threshold ignored.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/find_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find contiguous clusters in a time series — find_clusters","text":"data frame one row per detected cluster columns: cluster_id: integer cluster index (starting 1).       group provided, cluster_id restarts 1 within       group level; cluster_onset: time first point cluster; cluster_offset: time last point cluster; n_points: number time points cluster; sign: character indicating cluster sign       (\"positive\" \"negative\"). group NULL, returned data frame also contains   grouping column (named group). clusters found, empty data frame column structure   returned.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/find_clusters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find contiguous clusters in a time series — find_clusters","text":"default, function detects positive negative clusters single call returns column indicating cluster sign. grouping variable provided (e.g., \"participant\"), clusters detected independently within group level. function assumes time variable numeric consecutive rows correspond consecutive time points (within group grouping used). Internally, data : filtered remove rows missing values; arranged time (group time, used); thresholded identify positive /negative excursions; segmented runs consecutive threshold-exceeding values,         define clusters.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/find_clusters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find contiguous clusters in a time series — find_clusters","text":"Ladislas Nalborczyk ladislas.nalborczyk@cnrs.fr","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/find_clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find contiguous clusters in a time series — find_clusters","text":"","code":"set.seed(666) df <- data.frame(   time = seq(0, 1, length.out = 100),   value = c(     rnorm(30, 0, 1),     rnorm(20,  4, 1), # positive cluster     rnorm(20, -4, 1), # negative cluster     rnorm(30, 0, 1)     )   )  # Detect both positive and negative clusters find_clusters(data = df, threshold = 3) #>   cluster_id cluster_onset cluster_offset n_points     sign #> 1          1     0.3030303      0.3636364        7 positive #> 2          2     0.3838384      0.4444444        7 positive #> 3          3     0.4646465      0.4949495        4 positive #> 4          1     0.5050505      0.5050505        1 negative #> 5          2     0.5252525      0.5858586        7 negative #> 6          3     0.6060606      0.6262626        3 negative #> 7          4     0.6464646      0.6767677        4 negative #> 8          5     0.6969697      0.6969697        1 negative  # One-sided detection (positive only) find_clusters(data = df, threshold = 3, both_signs = FALSE, above_threshold = TRUE) #>   cluster_id cluster_onset cluster_offset n_points     sign #> 1          1     0.3030303      0.3636364        7 positive #> 2          2     0.3838384      0.4444444        7 positive #> 3          3     0.4646465      0.4949495        4 positive  # Grouped example (e.g., per participant) df_g <- rbind(   transform(df, participant = \"P01\"),   transform(df, participant = \"P02\")   )  find_clusters(   data = df_g,   threshold = 3,   group = \"participant\"   ) #>    participant cluster_id cluster_onset cluster_offset n_points     sign #> 1          P01          1     0.3030303      0.3636364        7 positive #> 2          P01          2     0.3838384      0.4444444        7 positive #> 3          P01          3     0.4646465      0.4949495        4 positive #> 4          P02          1     0.3030303      0.3636364        7 positive #> 5          P02          2     0.3838384      0.4444444        7 positive #> 6          P02          3     0.4646465      0.4949495        4 positive #> 7          P01          1     0.5050505      0.5050505        1 negative #> 8          P01          2     0.5252525      0.5858586        7 negative #> 9          P01          3     0.6060606      0.6262626        3 negative #> 10         P01          4     0.6464646      0.6767677        4 negative #> 11         P01          5     0.6969697      0.6969697        1 negative #> 12         P02          1     0.5050505      0.5050505        1 negative #> 13         P02          2     0.5252525      0.5858586        7 negative #> 14         P02          3     0.6060606      0.6262626        3 negative #> 15         P02          4     0.6464646      0.6767677        4 negative #> 16         P02          5     0.6969697      0.6969697        1 negative"},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_eeg.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","title":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","text":"Create facetted EEG maps across multiple time points either ) brms spatio-temporal model (predicted values) ii) raw/summarised EEG data long format (observed values).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_eeg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","text":"","code":"plot_eeg(   x,   type = c(\"topo\", \"surface\"),   times = NULL,   n_times = NULL,   sensors = NULL,   value_col = \"voltage\",   time_col = \"time\",   x_col = \"xproj\",   y_col = \"yproj\",   grid_res = 100,   head_expand = 1.1,   re_formula = NULL,   probs = c(0.025, 0.975),   ndraws = NULL,   show_sensors = TRUE,   sensor_size = 1.5,   sensor_labels = FALSE,   sensor_label_col = \"channel\",   sensor_label_size = 3,   sensor_label_repel = TRUE,   contours = TRUE,   contour_bins = 10,   palette = \"RdBu\",   facet_nrow = NULL,   facet_ncol = NULL,   facet_scales = \"fixed\",   facet_label_prefix = \"Time: \",   facet_unit = \"s\",   fill_limits = c(\"global_quantile\", \"global\", \"none\"),   limit_quantiles = c(0.01, 0.99) )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_eeg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","text":"x Either data frame containing EEG data (raw summarised) fitted brmsfit object. data frame provided, must contain columns specified time_col, x_col, y_col, value_col. brmsfit provided, predictions computed x$data x must include compatible spatio-temporal smooth (e.g., gp(time, xproj, yproj, ...) t2(time, xproj, yproj, ...)). type Character; plot type. \"topo\" draws scalp outline masks values outside head. \"surface\" draws interpolated/predicted field. times Numeric vector time points plot. NULL, unique times found input used (subset n_times provided). n_times Optional integer; NULL, selects n_times approximately equally spaced time points times. sensors Optional data frame sensor positions used draw head outline, sensor points, sensor labels. Must contain columns xproj yproj. NULL, sensor coordinates inferred unique x_col/y_col pairs x (labels unavailable). value_col Character; name value column raw data (e.g., \"voltage\"). time_col, x_col, y_col Character; column names x giving time 2D sensor coordinates (projected). grid_res Integer; grid resolution used evaluate predictions /interpolate data regular grid (approximately grid_res^2 pixels per facet). head_expand Numeric; expansion factor used compute head radius sensor coordinates (values > 1 add padding). re_formula Passed brms::fitted x brmsfit. Use NULL default behaviour, NA exclude group-level terms. probs Numeric vector length 2 giving quantiles returned brms::fitted(..., probs = probs). ndraws Optional integer; number posterior draws used brms::fitted. show_sensors Logical; TRUE type = \"topo\", plot sensor points. sensor_size Numeric; point size sensors. sensor_labels Logical; TRUE, add sensor labels (requires sensors contain sensor_label_col). sensor_label_col Character; column name sensors providing sensor names. sensor_label_size Numeric; text size sensor labels. sensor_label_repel Logical; TRUE, use ggrepel labels. contours Logical; TRUE, add contour lines. contour_bins Integer; number contour bins. palette Character; palette name passed scale_fill_distiller. facet_nrow, facet_ncol Integers; layout facet_wrap. facet_scales Character; facet scaling, passed facet_wrap(scales = ...). facet_label_prefix Character; prefix used generating facet labels (e.g., \"Time: \"). facet_unit Character; unit suffix used generating facet labels (e.g., \"s\"). fill_limits Character; set colour scale limits. \"global_quantile\" uses limit_quantiles define robust symmetric limits, \"global\" uses full range, \"none\" leaves limits ggplot. limit_quantiles Numeric vector length 2; quantiles used fill_limits = \"global_quantile\".","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_eeg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","text":"ggplot object.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_eeg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","text":"function can render either scalp topography (type = \"topo\") head outline optional sensor markers/labels, simple 2D surface plot (type = \"surface\") without head outline. type = \"topo\", values masked outside head radius computed sensor coordinates head outline (circle + nose + ears) drawn. raw data, values interpolated regular grid per time point using st_interp_to_grid(), relies akima can optionally fill missing grid cells using nearest-neighbour (FNN). brmsfit inputs, predictions obtained via brms::fitted() regular grid. type = \"topo\", missing values inside head can filled using st_fill_head() (nearest-neighbour). function relies internal helpers st_take_n_times(), st_make_grid(), st_head_radius(), st_head_outline(), st_build_time_labels(), st_order_time_factor(), st_compute_limits(), st_predict_brms(), st_fill_head(), st_interp_to_grid().","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_eeg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","text":"Ladislas Nalborczyk ladislas.nalborczyk@cnrs.fr","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_eeg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot spatio-temporal EEG data as topographies or 2D surfaces — plot_eeg","text":"","code":"if (FALSE) { # \\dontrun{ # Summarised EEG data (long format) plot_eeg(   eeg_data_summary,   type = \"topo\",   sensors = sensors,   times = c(0, 0.1, 0.2, 0.3),   grid_res = 80,   contours = FALSE,   facet_nrow = 2   )  # brms model predictions plot_eeg(   spatio_temporal_gam,   type = \"topo\",   sensors = sensors,   times = c(0, 0.1, 0.2, 0.3),   ndraws = 200   ) } # }"},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_sensors.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot EEG sensor positions on a 2D scalp — plot_sensors","title":"Plot EEG sensor positions on a 2D scalp — plot_sensors","text":"Visualise 2D layout EEG sensors using projected coordinates (e.g., xproj yproj). Optionally draws head outline, sensor markers, /sensor labels. subset sensors can highlighted (name row index), non-highlighted sensors optionally dimmed.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_sensors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot EEG sensor positions on a 2D scalp — plot_sensors","text":"","code":"plot_sensors(   sensors,   x_col = \"xproj\",   y_col = \"yproj\",   label_col = \"channel\",   show_head = TRUE,   head_expand = 1.1,   show_points = FALSE,   point_size = 2,   show_labels = TRUE,   label_size = 3,   label_repel = TRUE,   label_only_highlight = FALSE,   highlight = NULL,   highlight_col = \"orangered\",   highlight_size = 3,   highlight_shape = 16,   highlight_alpha = 1,   dim_others = TRUE,   other_alpha = 0.3,   xlim = NULL,   ylim = NULL )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_sensors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot EEG sensor positions on a 2D scalp — plot_sensors","text":"sensors data frame containing sensor coordinates. Must include columns specified x_col y_col. show_labels = TRUE labels desired, must also include label_col. x_col, y_col Character scalars giving column names sensors corresponding x y projected sensor coordinates. label_col Character scalar giving column name sensors used sensor labels (e.g., \"channel\"). show_head Logical; TRUE, draw head outline (circle + nose + ears). head_expand Numeric scalar; multiplier applied maximum sensor radius computing head radius. Values > 1 add padding around sensors. show_points Logical; TRUE, draw sensor markers non-highlighted sensors. point_size Numeric; size non-highlighted sensor markers. show_labels Logical; TRUE, add sensor labels. label_size Numeric; text size sensor labels. label_repel Logical; TRUE, use ggrepel reduce label overlap. FALSE, uses geom_text. label_only_highlight Logical; TRUE highlight NULL, show labels highlighted sensors. highlight Optional vector specifying sensors highlight. numeric, treated row indices sensors. Otherwise treated sensor names matched sensors[[label_col]]. highlight_col Character; colour used highlighted sensors. highlight_size Numeric; marker size highlighted sensors. highlight_shape Numeric; point shape highlighted sensors (ggplot2). highlight_alpha Numeric [0, 1]; alpha transparency highlighted sensors. dim_others Logical; TRUE, apply other_alpha non-highlighted sensor markers show_points = TRUE. other_alpha Numeric [0, 1]; alpha transparency non-highlighted sensors dim_others = TRUE. xlim, ylim Optional numeric vectors length 2 giving x y limits. NULL, limits computed automatically head radius (show_head = TRUE) range sensor coordinates otherwise.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_sensors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot EEG sensor positions on a 2D scalp — plot_sensors","text":"ggplot object.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_sensors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot EEG sensor positions on a 2D scalp — plot_sensors","text":"head outline computed maximum sensor radius (multiplied head_expand) using st_head_radius() st_head_outline(). helper functions must available calling environment. Highlighting works two modes: highlight numeric, indices used mark rows sensors. highlight character, values matched sensors[[label_col]].","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_sensors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot EEG sensor positions on a 2D scalp — plot_sensors","text":"Ladislas Nalborczyk ladislas.nalborczyk@cnrs.fr","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/plot_sensors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot EEG sensor positions on a 2D scalp — plot_sensors","text":"","code":"if (FALSE) { # \\dontrun{ # Basic sensor layout with head outline and labels plot_sensors(sensors, show_points = TRUE, show_labels = TRUE)  # Highlight a few channels by name plot_sensors(   sensors,   show_points = TRUE,   show_labels = TRUE,   highlight = c(\"CZ\", \"C1\", \"C2\"),   label_only_highlight = TRUE   )  # Highlight by row index plot_sensors(   sensors,   show_points = TRUE,   highlight = c(10, 25, 42),   highlight_col = \"dodgerblue\"   ) } # }"},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc.html","id":null,"dir":"Reference","previous_headings":"","what":"Posterior predictive checks — ppc","title":"Posterior predictive checks — ppc","text":"Generate posterior predictive checks (PPCs) fitted Bayesian time-resolved GAMM stored clusters_results object. PPCs can produced either group level separately participant.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Posterior predictive checks — ppc","text":"","code":"ppc(   object,   ppc_type = c(\"group\", \"participant\"),   ndraws = 500,   group_var = NULL,   cores = 4,   ... )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Posterior predictive checks — ppc","text":"object clusters_results object containing fitted brmsfit model object$model. ppc_type Character string specifying type PPC generate. Either \"group\" (default) group-level PPCs (ignoring participant identity) \"participant\" participant-wise PPCs. ndraws Integer specifying number posterior draws use PPC. Defaults 500. group_var Optional character; name grouping variable use grouped PPCs group level. NULL (default), function uses \"predictor\" present model$data binary (two levels). cores Numeric; number parallel cores use (used ppc_type = \"participant\"). ... Currently unused. Included future extensions.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Posterior predictive checks — ppc","text":"ggplot object visualising posterior predictive check. plot printed active graphics device also returned invisibly.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Posterior predictive checks — ppc","text":"group level, predictions obtained simulating posterior using posterior_predict re_formula = NA, collapsing original data across participants (time). participant level, PPCs generated using pp_check grouped ribbons. Group-level PPCs computed averaging numeric variables   across participants time point, simulating posterior predictive   draws random effects excluded (re_formula = NA).   provides marginal, population-level posterior predictive check. Participant-level PPCs computed using grouped ribbon   plots, showing posterior predictive distributions separately   participant. returned object ggplot2 object produced ppc_ribbon pp_check, depending selected ppc_type.","code":""},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Posterior predictive checks — ppc","text":"","code":"if (FALSE) { # \\dontrun{ # Group-level PPC ppc(object = res, ppc_type = \"group\")  # Participant-level PPC ppc(object = res, ppc_type = \"participant\") } # }"},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc_clusters_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Posterior predictive checks for time-resolved BGAMMs — ppc_clusters_results","title":"Posterior predictive checks for time-resolved BGAMMs — ppc_clusters_results","text":"Generates posterior predictive checks (PPCs) brms model stored inside \"clusters_results\" object, displaying: PPC predicted outcome distribution (densities), PPC summary statistics (mean standard deviation).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc_clusters_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Posterior predictive checks for time-resolved BGAMMs — ppc_clusters_results","text":"","code":"ppc_clusters_results(   object,   ndraws_time = 100,   ndraws_stat = 100,   stat = c(\"mean\", \"sd\"),   group_var = NULL,   ... )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc_clusters_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Posterior predictive checks for time-resolved BGAMMs — ppc_clusters_results","text":"object object class \"clusters_results\" returned testing_through_time. object must contain fitted brms model $model slot. ndraws_time Integer; number posterior draws used distribution-level PPC (density overlay). Defaults 100. ndraws_stat Integer; number posterior draws used statistic-level PPC (mean/SD). Defaults 500. stat character vector summary statistics use \"stat_2d\" PPC. Passed pp_check stat argument. Defaults c(\"mean\", \"sd\"). group_var Optional character scalar specifying name grouping variable grouped PPC. NULL (default), function automatically uses \"predictor\" column exists model data exactly two levels (binary predictor). grouping variable used, density PPC employs type = \"dens_overlay_grouped\"; otherwise, type = \"dens_overlay\". ... Currently ignored. Included future extensibility.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc_clusters_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Posterior predictive checks for time-resolved BGAMMs — ppc_clusters_results","text":"patchwork / ggplot2 object containing combined   posterior predictive checks. plot also printed side effect.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc_clusters_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Posterior predictive checks for time-resolved BGAMMs — ppc_clusters_results","text":"function convenience wrapper around pp_check patchwork. first tries detect whether model contains binary grouping variable (default, column named \"predictor\" model$data). variable found (group_var explicitly provided), distribution-level PPC produced using type = \"dens_overlay_grouped\", compares predicted observed densities within group. Otherwise, standard type = \"dens_overlay\" PPC drawn. second panel uses type = \"stat_2d\" supplied stat argument (default, mean standard deviation), allowing inspection well posterior predictive distribution reproduces key summary statistics data. two PPC plots combined side--side using wrap_plots, resulting combined plot returned (can modified using standard ggplot2 patchwork operations).","code":""},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/reference/ppc_clusters_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Posterior predictive checks for time-resolved BGAMMs — ppc_clusters_results","text":"","code":"if (FALSE) { # \\dontrun{ # import some simulated EEG data data(eeg_data) head(eeg_data)  # fit time-resolved model (one-sample test) res <- testing_through_time(   data = eeg_data,   participant_id = \"participant\",   outcome_id = \"eeg\",   time_id = \"time\",   predictor_id = NA,   kvalue = 20,   multilevel = \"summary\"   )  # posterior predictive checks (combined plot) ppc_clusters_results(res) } # }"},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.clusters_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for clusters_results objects — print.clusters_results","title":"Print method for clusters_results objects — print.clusters_results","text":"method provides concise console representation output testing_through_time, including number detected clusters compact table summarising cluster's onset, offset, duration. Values rounded readability.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.clusters_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for clusters_results objects — print.clusters_results","text":"","code":"# S3 method for class 'clusters_results' print(x, digits = 3, ...)"},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.clusters_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for clusters_results objects — print.clusters_results","text":"x object class \"clusters_results\" returned testing_through_time. digits Integer; number decimal places used printing numeric values (default: 3). ... Additional arguments (currently ignored).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.clusters_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for clusters_results objects — print.clusters_results","text":"input object x, returned invisibly.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.clusters_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print method for clusters_results objects — print.clusters_results","text":"printed cluster table includes: cluster_id: numeric identifier cluster; cluster_onset: estimated temporal onset cluster; cluster_offset: estimated temporal offset cluster; duration: duration cluster, computed     cluster_offset - cluster_onset. clusters exceed posterior odds threshold, informative message displayed table printed.","code":""},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.recommend_k_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for recommend_k_results objects — print.recommend_k_results","title":"Print method for recommend_k_results objects — print.recommend_k_results","text":"Pretty printer objects class \"recommend_k_results\" returned k-recommendation procedure (e.g., based effective number parameters p_loo p_waic).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.recommend_k_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for recommend_k_results objects — print.recommend_k_results","text":"","code":"# S3 method for class 'recommend_k_results' print(x, digits = 3, ...)"},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.recommend_k_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for recommend_k_results objects — print.recommend_k_results","text":"x object class \"recommend_k_results\". digits Integer; number digits display numeric summaries. ... arguments passed methods (currently ignored).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/print.recommend_k_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for recommend_k_results objects — print.recommend_k_results","text":"input object x, invisibly.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/recommend_k.html","id":null,"dir":"Reference","previous_headings":"","what":"Recommend a smooth basis dimension k via effective complexity ","title":"Recommend a smooth basis dimension k via effective complexity ","text":"function takes \"clusters_results\" object produced testing_through_time, refits underlying brms model grid k values, computes model comparison criteria (loo, waic), identifies recommended smooth basis dimension via automatic \"knee\" detection procedure effective number parameters (either p_loo p_waic).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/recommend_k.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recommend a smooth basis dimension k via effective complexity ","text":"","code":"recommend_k(   object,   k_min = 10,   k_max = 40,   k_step = 5,   criterion = c(\"waic\", \"loo\"),   knee_method = c(\"geometric_smooth\", \"geometric\"),   loess_span = 0.5,   cores = 4,   verbose = TRUE )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/recommend_k.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recommend a smooth basis dimension k via effective complexity ","text":"object object class \"clusters_results\" returned testing_through_time. object must contain fitted brms model $model slot. k_min Numeric; minimum value smooth basis dimension k consider. k_max Numeric; maximum value smooth basis dimension k consider. k_step Numeric; step size successive k values. sequence tested values seq(k_min, k_max, = k_step). criterion Character vector model comparison criteria add via add_criterion. Defaults c(\"waic\", \"loo\"). knee_method Character; method knee detection. One : \"geometric\": standard geometric elbow raw         p_* values; \"geometric_smooth\": geometric elbow loess-smoothed         curve p_* vs k, weights         1 / SE(p_*)^2 available (recommended         p_* estimates noisy). loess_span Numeric; smoothing parameter passed loess knee_method = \"geometric_smooth\". Defaults 0.75. cores Numeric; number parallel cores use. verbose Logical; TRUE (default), prints progress messages refitting models different k values.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/recommend_k.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recommend a smooth basis dimension k via effective complexity ","text":"object class \"recommend_k_results\", list   elements: models: named list refitted brmsfit objects,       one per k value; comparison: data frame summarising model criteria       k (one row per k), including p_* SE; k_values: numeric vector k values       evaluated; recommended_k: k value identified knee       based chosen effective complexity measure method; plot: ggplot2 object displaying p_*       function k error bars knee highlighted; knee_on: complexity measure used (\"p_loo\"       \"p_waic\"); knee_method: knee detection method used.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/recommend_k.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recommend a smooth basis dimension k via effective complexity ","text":"k seq(k_min, k_max, = k_step), function: updates s(..., k = ...) terms original brms     formula use new value k, refits model via     update(); calls add_criterion compute requested     criteria, extracts p_loo p_waic standard     errors (available); builds comparison table criteria values across k. recommend basis dimension, function treats chosen complexity measure (p_loo p_waic) function k uses elbow (knee) method: knee_method = \"geometric\" applies geometric knee         procedure directly p_* vs k; knee_method = \"geometric_smooth\" first fits loess curve         p_* ~ k (weights 1 / SE(p_*)^2 available),         applies geometric knee smoothed curve.         reduces influence noisy p_* estimates. resulting plot shows p_* vs k : points line raw p_* estimates; vertical error bars ± SE(p_*) (SEs available); (optionally) dashed line smoothed p_* curve; vertical dashed line recommended k (knee).","code":""},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/reference/recommend_k.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Recommend a smooth basis dimension k via effective complexity ","text":"Ladislas Nalborczyk ladislas.nalborczyk@cnrs.fr.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/recommend_k.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recommend a smooth basis dimension k via effective complexity ","text":"","code":"if (FALSE) { # \\dontrun{ # import some simulated EEG data data(eeg_data) head(eeg_data)  # fit a time-resolved GAMM res <- testing_through_time(   data = eeg_data,   participant_id = \"participant\",   outcome_id = \"eeg\",   time_id = \"time\",   predictor_id = NA,   kvalue = 20,   multilevel = \"summary\"   )  # recommend an optimal smooth basis dimension k k_res <- recommend_k(   object = res,   k_min = 10,   k_max = 40,   k_step = 5   )  # print summary in the console summary(k_res)  # extract the recommended k value k_res$recommended_k  # access the comparison table k_res$comparison  # visualise effective complexity vs. k k_res$plot } # }"},{"path":"https://lnalborczyk.github.io/neurogam/reference/st_take_n_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Select approximately equally spaced times — st_take_n_times","title":"Select approximately equally spaced times — st_take_n_times","text":"Select approximately equally spaced times","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/st_take_n_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select approximately equally spaced times — st_take_n_times","text":"","code":"st_take_n_times(time_vec, N)"},{"path":"https://lnalborczyk.github.io/neurogam/reference/st_take_n_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select approximately equally spaced times — st_take_n_times","text":"time_vec Numeric vector. N Integer number points.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/st_take_n_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select approximately equally spaced times — st_take_n_times","text":"Subset time_vec.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.clusters_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for clusters_results objects — summary.clusters_results","title":"Summary method for clusters_results objects — summary.clusters_results","text":"Produces detailed textual summary time-resolved Bayesian GAMM analysis, including model metadata, number clusters detected, descriptive statistics cluster durations. rounded cluster table also printed.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.clusters_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for clusters_results objects — summary.clusters_results","text":"","code":"# S3 method for class 'clusters_results' summary(object, digits = 3, ...)"},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.clusters_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for clusters_results objects — summary.clusters_results","text":"object object class \"clusters_results\" created testing_through_time. digits Integer; number decimal places used printing numeric values (default: 3). ... Additional arguments (currently ignored).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.clusters_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for clusters_results objects — summary.clusters_results","text":"object object, returned invisibly.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.clusters_results.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary method for clusters_results objects — summary.clusters_results","text":"summary prints: model type used (\"full\", \"summary\",     \"group\"); class underlying brms model number     posterior draws; number clusters detected posterior odds threshold; descriptive statistics cluster durations (minimum, maximum,     mean, median, total duration); neatly formatted table listing cluster's onset, offset,     duration. clusters detected, function prints message returns invisibly.","code":""},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.recommend_k_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for recommend_k_results objects — summary.recommend_k_results","title":"Summary method for recommend_k_results objects — summary.recommend_k_results","text":"Provides concise summary k-tuning results, including range tested k values, effective complexity measures (e.g., p_loo p_waic), recommended k obtained via knee detection.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.recommend_k_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for recommend_k_results objects — summary.recommend_k_results","text":"","code":"# S3 method for class 'recommend_k_results' summary(object, digits = 3, ...)"},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.recommend_k_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for recommend_k_results objects — summary.recommend_k_results","text":"object object class \"recommend_k_results\". digits Integer; number digits display numeric summaries. ... arguments passed methods (currently ignored).","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/summary.recommend_k_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for recommend_k_results objects — summary.recommend_k_results","text":"input object object, invisibly.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/testing_through_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-resolved testing based on BGAMMs — testing_through_time","title":"Time-resolved testing based on BGAMMs — testing_through_time","text":"Fits time-resolved Bayesian generalised additive (multilevel) models (BGAMMs) using brms, computes posterior odds effect time point. effect can either ) deviation outcome reference value (e.g., zero chance level), ii) difference two groups/conditions.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/testing_through_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-resolved testing based on BGAMMs — testing_through_time","text":"","code":"testing_through_time(   data,   participant_id = \"participant\",   outcome_id = \"eeg\",   time_id = \"time\",   predictor_id = \"condition\",   family = gaussian(),   kvalue = 20,   bs = \"tp\",   multilevel = c(\"summary\", \"group\"),   by_ppt = FALSE,   warmup = 1000,   iter = 2000,   chains = 4,   cores = 4,   backend = \"cmdstanr\",   threshold = 10,   n_post_samples = NULL,   chance_level = 0,   sesoi = 0,   credible_interval = 0.95 )"},{"path":"https://lnalborczyk.github.io/neurogam/reference/testing_through_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-resolved testing based on BGAMMs — testing_through_time","text":"data data frame long format containing time-resolved data. participant_id Character; name column data specifying participant IDs. outcome_id Character; name column data containing outcome values (e.g., M/EEG amplitude, decoding accuracy). time_id Character; name column data containing time information (e.g., seconds samples). predictor_id Character; name column data containing either: binary categorical predictor (e.g., group condition),     case function tests, time point, whether     difference two levels exceeds     chance_level + sesoi; continuous numeric predictor, case function     tests, time point, whether slope outcome     respect predictor differs chance_level + sesoi     (typically chance_level = 0). predictor_id = NA, function tests whether outcome differs     chance_level + sesoi time (useful decoding accuracies,     instance). family brms family object describing response distribution used model (defaults gaussian()). kvalue Numeric; basis dimension k passed smooth term s(time, ..., k = kvalue). bs Character; Character scalar; type spline basis used brms (passed s(), e.g., \"tp\" thin-plate splines). multilevel Character; model fit. One \"summary\": GAMM fitted participant-level summary     statistics (mean outcome standard deviation); \"group\": Group-level GAM fitted participant-averaged     data (random/varying effects). by_ppt Logical; return clusters participant-level. warmup Numeric; number warm-iterations per chain. iter Numeric; total number iterations per chain (including warmup). chains Numeric; number MCMCs. cores Numeric; number parallel cores use. backend Character; package use backend fitting Stan model. One \"cmdstanr\" (default) \"rstan\". threshold Numeric; threshold posterior odds (prob_ratio) used define contiguous temporal clusters. Values greater 1 favour hypothesis effect exceeds chance_level + sesoi. n_post_samples Numeric; number posterior draws used compute posterior probabilities. NULL (default), available draws fitted model used. chance_level Numeric; reference value outcome (e.g., 0.5 decoding accuracy). used testing constant (.e., predictor_id effect difference chance). sesoi Numeric; smallest effect size interest (SESOI). posterior probability computed effect strictly larger chance_level + sesoi. credible_interval Numeric; width credible (quantile) interval.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/testing_through_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time-resolved testing based on BGAMMs — testing_through_time","text":"object class \"clusters_results\", list   elements: clusters: data frame one row per detected cluster       (e.g., cluster_onset, cluster_offset, duration); predictions: data frame time-resolved posterior       summaries (posterior median, credible interval, posterior       probabilities, odds prob_ratio); data: data used fit brms model       (possibly summarised); model: fitted brms model object; multilevel: value multilevel argument. object associated plot() method visualising   smoothed time course detected clusters, well print()   summary() methods.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/testing_through_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Time-resolved testing based on BGAMMs — testing_through_time","text":"Internally, function: builds formula smooth term time (optionally group); fits brms model according multilevel; uses tidybayes extract posterior predictions time; computes, time point, posterior probability     effect (condition difference) exceeds chance_level + sesoi; converts posterior odds (prob_ratio) applies     clustering procedure (find_clusters()) time.","code":""},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/reference/testing_through_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Time-resolved testing based on BGAMMs — testing_through_time","text":"Ladislas Nalborczyk ladislas.nalborczyk@cnrs.fr.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/reference/testing_through_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-resolved testing based on BGAMMs — testing_through_time","text":"","code":"if (FALSE) { # \\dontrun{ # import some simulated EEG data data(eeg_data) head(eeg_data)  # fit the BGAMM to identify clusters results <- testing_through_time(data = eeg_data)  # display the identified clusters print(results$clusters)  # plot the GAM-smoothed signal and identified clusters plot(results) } # }"},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/news/index.html","id":"new-features-0-0-3","dir":"Changelog","previous_headings":"","what":"New features","title":"neurogam 0.0.3","text":"Implementing recommend_k() function, running model comparison varying basis dimension (k). Implementing ppc() method cluster_results objects. New plot_sensors() plot_eeg() functions visualise EEG sensors grid, EEG raw data, GAM predictions. Adding support returning participant-level onsets testing_through_time(), find_clusters(), related methods summary() plot().","code":""},{"path":"https://lnalborczyk.github.io/neurogam/news/index.html","id":"other-changes-0-0-3","dir":"Changelog","previous_headings":"","what":"Other changes","title":"neurogam 0.0.3","text":"Improved documentation print() summary() methods. Removed multilevel = \"full\" option (slow). Now returns clusters positive negative signs find_clusters().","code":""},{"path":"https://lnalborczyk.github.io/neurogam/news/index.html","id":"bug-fixes-0-0-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"neurogam 0.0.3","text":"Fixing aberrant PPCs ppc() method (simplifying arguments ppc_type = c(\"group\", \"participant\")).","code":""},{"path":[]},{"path":"https://lnalborczyk.github.io/neurogam/news/index.html","id":"new-features-0-0-2","dir":"Changelog","previous_headings":"","what":"New features","title":"neurogam 0.0.2","text":"Allowing 3 different models fitted: full GAMM, GAMM summary statistics (recommended), group-level GAM. Adding support presence absence predictor (e.g., group, condition). predictor_id = NA, neurogam now tests signal 0 time. Implementing print() summary() methods cluster_results objects. Improved plotting: now plotting GAM predictions raw data improved clusters aesthetics.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/news/index.html","id":"other-changes-0-0-2","dir":"Changelog","previous_headings":"","what":"Other changes","title":"neurogam 0.0.2","text":"Improved functions documentation new package website. Factoring posterior odds computation within internal functions.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/news/index.html","id":"bug-fixes-0-0-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"neurogam 0.0.2","text":"Fixing group-level posterior predictions multilevel “full” “summary”.","code":""},{"path":"https://lnalborczyk.github.io/neurogam/news/index.html","id":"neurogam-001","dir":"Changelog","previous_headings":"","what":"neurogam 0.0.1","title":"neurogam 0.0.1","text":"Pushing first version neurogam.","code":""}]
