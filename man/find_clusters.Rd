% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_clusters.R
\name{find_clusters}
\alias{find_clusters}
\title{Find contiguous clusters in a time series}
\usage{
find_clusters(
  data,
  threshold = 10,
  group = NULL,
  threshold_type = c("both", "above", "below")
)
}
\arguments{
\item{data}{A data frame containing at least two columns named
\code{"time"} and \code{"value"}. If \code{group} is not \code{NULL},
\code{data} must also contain that grouping column.}

\item{threshold}{Numeric scalar specifying the (positive) threshold used to
define clusters. Positive clusters are defined where
\code{value >= threshold}, and negative clusters where
\code{value <= 1/threshold}. Must be non-negative when
\code{threshold_type = "both"}.}

\item{group}{Optional grouping column name (character scalar) used to find
clusters independently within each group level (e.g.,
\code{"participant"}). Set to \code{NULL} (default) to ignore grouping.}

\item{threshold_type}{Character scalar controlling which clusters are
detected. Must be one of \code{"above"}, \code{"below"}, or \code{"both"}
(default). When \code{"above"}, clusters are formed where
\code{value >= threshold}. When \code{"below"}, clusters are formed where
\code{value <= 1/threshold}. When \code{"both"}, both types are detected
and the returned data include a \code{sign} column.}
}
\value{
A data frame with one row per detected cluster and columns:
  \itemize{
    \item \code{id}: integer cluster index (starting at 1). When
      \code{group} is provided, \code{id} restarts at 1 within each
      group level;
    \item \code{onset}: time of the first point in the cluster;
    \item \code{offset}: time of the last point in the cluster;
    \item \code{n_points}: number of time points in the cluster;
    \item \code{sign}: character indicating cluster sign
      (\code{"positive"} or \code{"negative"}).
  }

  If \code{group} is not \code{NULL}, the returned data frame also contains
  the grouping column (named as in \code{group}).

  If no clusters are found, an empty data frame with the same column structure
  is returned.
}
\description{
Identify contiguous clusters of time points in a time series where a
variable exceeds a positive threshold, falls below a negative threshold,
or both. Clusters are defined as consecutive time points satisfying the
thresholding condition.
}
\details{
By default, the function detects \strong{both positive and negative clusters}
in a single call and returns a column indicating the cluster sign.

If a grouping variable is provided (e.g., \code{"participant"}), clusters
are detected independently within each group level.


The function assumes that the \code{time} variable is numeric and that
consecutive rows correspond to consecutive time points (within each group
if grouping is used). Internally, the data are:
\enumerate{
  \item filtered to remove rows with missing values;
  \item arranged by \code{time} (and by \code{group} then \code{time}, if used);
  \item thresholded to identify positive and/or negative excursions;
  \item segmented into runs of consecutive threshold-exceeding values,
        which define clusters.
}
}
\examples{
set.seed(666)
df <- data.frame(
  time = seq(0, 1, length.out = 100),
  value = c(
    rnorm(30, 0, 1),
    rnorm(20,  4, 1), # positive cluster
    rnorm(20, -4, 1), # negative cluster
    rnorm(30, 0, 1)
    )
  )

# Detect both positive and negative clusters
find_clusters(data = df, threshold = 3, threshold_type = "both")

# One-sided detection (positive only)
find_clusters(data = df, threshold = 3, threshold_type = "above")

# One-sided detection (negative only)
find_clusters(data = df, threshold = 3, threshold_type = "below")

# Grouped example (e.g., per participant)
df_g <- rbind(
  transform(df, participant = "P01"),
  transform(df, participant = "P02")
  )

find_clusters(
  data = df_g,
  threshold = 3,
  group = "participant",
  threshold_type = "both"
  )

}
\author{
Ladislas Nalborczyk \email{ladislas.nalborczyk@cnrs.fr}
}
