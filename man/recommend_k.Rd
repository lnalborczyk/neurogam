% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recommend_k.R
\name{recommend_k}
\alias{recommend_k}
\title{Recommend a smooth basis dimension k via effective complexity "knee" detection}
\usage{
recommend_k(
  object,
  k_min = 10,
  k_max = 40,
  k_step = 5,
  criterion = c("waic", "loo"),
  knee_method = c("geometric_smooth", "geometric"),
  loess_span = 0.75,
  verbose = TRUE
)
}
\arguments{
\item{object}{An object of class \code{"clusters_results"} as returned by
\code{\link{testing_through_time}}. The object must contain a fitted
\pkg{brms} model in its \code{$model} slot.}

\item{k_min}{Numeric; minimum value of the smooth basis dimension
\code{k} to consider.}

\item{k_max}{Numeric; maximum value of the smooth basis dimension
\code{k} to consider.}

\item{k_step}{Numeric; step size between successive \code{k} values.
The sequence of tested values is \code{seq(k_min, k_max, by = k_step)}.}

\item{criterion}{Character vector of model comparison criteria to add via
\code{\link[brms]{add_criterion}}. Defaults to
\code{c("waic", "loo")}.}

\item{knee_method}{Character; method for knee detection. One of:
\itemize{
  \item \code{"geometric"}: standard geometric elbow on the raw
        \code{p_*} values;
  \item \code{"geometric_smooth"}: geometric elbow on a loess-smoothed
        curve of \code{p_*} vs \code{k}, with weights
        \code{1 / SE(p_*)^2} when available (recommended when
        \code{p_*} estimates are noisy).
}}

\item{loess_span}{Numeric; smoothing parameter passed to
\code{\link[stats]{loess}} when \code{knee_method = "geometric_smooth"}.
Defaults to \code{0.75}.}

\item{verbose}{Logical; if \code{TRUE} (default), prints progress messages
while refitting models for different \code{k} values.}
}
\value{
An object of class \code{"recommend_k_results"}, which is a list
  with elements:
  \itemize{
    \item \code{models}: named list of refitted \code{brmsfit} objects,
      one per \code{k} value;
    \item \code{comparison}: data frame summarising model criteria for each
      \code{k} (one row per \code{k}), including \code{p_*} and its SE;
    \item \code{k_values}: numeric vector of \code{k} values that were
      evaluated;
    \item \code{recommended_k}: the \code{k} value identified as the knee
      based on the chosen effective complexity measure and method;
    \item \code{plot}: a \code{ggplot2} object displaying \code{p_*} as a
      function of \code{k} with error bars and the knee highlighted;
    \item \code{knee_on}: the complexity measure used (\code{"p_loo"} or
      \code{"p_waic"});
    \item \code{knee_method}: the knee detection method used.
  }
}
\description{
This function takes a \code{"clusters_results"} object produced by
\code{\link{testing_through_time}}, refits the underlying \pkg{brms} model
for a grid of \code{k} values, computes model comparison criteria
(\code{loo}, \code{waic}), and identifies a recommended
smooth basis dimension via an automatic "knee" detection procedure on the
effective number of parameters (either \code{p_loo} or \code{p_waic}).
}
\details{
For each \code{k} in \code{seq(k_min, k_max, by = k_step)}, the function:
\enumerate{
  \item updates all \code{s(..., k = ...)} terms in the original \pkg{brms}
    formula to use the new value \code{k}, and refits the model via
    \code{update()};
  \item calls \code{\link[brms]{add_criterion}} to compute the requested
    criteria, and extracts \code{p_loo} or \code{p_waic} and their standard
    errors (where available);
  \item builds a comparison table of criteria values across \code{k}.
}

To recommend a basis dimension, the function treats the chosen complexity
measure (\code{p_loo} or \code{p_waic}) as a function of \code{k} and uses
an elbow (knee) method:
\itemize{
  \item \code{knee_method = "geometric"} applies the geometric knee
        procedure directly to \code{p_*} vs \code{k};
  \item \code{knee_method = "geometric_smooth"} first fits a loess curve
        \code{p_* ~ k} (with weights \code{1 / SE(p_*)^2} when available),
        then applies the geometric knee to the smoothed curve. This
        reduces the influence of noisy \code{p_*} estimates.
}

The resulting plot shows \code{p_*} vs \code{k} with:
\itemize{
  \item points and a line for the raw \code{p_*} estimates;
  \item vertical error bars \code{Â± SE(p_*)} (when SEs are available);
  \item (optionally) a dashed line for the smoothed \code{p_*} curve;
  \item a vertical dashed line at the recommended \code{k} (knee).
}
}
\examples{
\dontrun{
# import some simulated EEG data
data(eeg_data)
head(eeg_data)

# fit a time-resolved GAMM
res <- testing_through_time(
  data = eeg_data,
  participant_id = "participant",
  outcome_id = "eeg",
  time_id = "time",
  predictor_id = NA,
  kvalue = 20,
  multilevel = "summary"
  )

# recommend an optimal smooth basis dimension k
k_res <- recommend_k(
  object = res,
  k_min = 10,
  k_max = 40,
  k_step = 5,
  criterion = "waic"
  )

# print summary in the console
summary(k_res)

# extract the recommended k value
k_res$recommended_k

# access the comparison table
k_res$comparison

# visualise effective complexity vs. k
k_res$plot
}

}
\seealso{
\code{\link{testing_through_time}},
  \code{\link[brms]{brm}},
  \code{\link[brms]{add_criterion}}
  \code{\link[stats]{loess}}
}
\author{
Ladislas Nalborczyk \email{ladislas.nalborczyk@cnrs.fr}.
}
