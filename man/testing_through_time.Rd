% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/testing_through_time.R
\name{testing_through_time}
\alias{testing_through_time}
\title{Time-resolved testing based on BGAMMs}
\usage{
testing_through_time(
  data,
  participant_id = "participant",
  outcome_id = "eeg",
  time_id = "time",
  predictor_id = "condition",
  trials_id = NULL,
  family = gaussian(),
  kvalue = 20,
  bs = "tp",
  multilevel = c("summary", "group"),
  include_ar_term = FALSE,
  participant_clusters = FALSE,
  varying_smooth = TRUE,
  warmup = 1000,
  iter = 2000,
  chains = 4,
  cores = 4,
  backend = c("cmdstanr", "rstan"),
  stan_control = NULL,
  n_post_samples = NULL,
  threshold = 10,
  threshold_type = c("both", "above", "below"),
  chance_level = NULL,
  credible_interval = 0.95
)
}
\arguments{
\item{data}{A data frame in long format containing time-resolved data.}

\item{participant_id}{Character; name of the column in \code{data}
specifying participant IDs.}

\item{outcome_id}{Character; name of the column in \code{data} containing
the outcome values (e.g., M/EEG amplitude, decoding accuracy).}

\item{time_id}{Character; name of the column in \code{data}
containing time information (e.g., in seconds or samples).}

\item{predictor_id}{Character; name of the column in \code{data}
containing either:
\itemize{
  \item A \emph{binary} categorical predictor (e.g., group or condition),
    in which case the function tests, at each time point, whether the
    difference between the two levels differs from
    \code{chance_level};
  \item A \emph{continuous} numeric predictor, in which case the function
    tests, at each time point, whether the difference between the average
    value of the predictor +1SD and the average value -1SD differs from
    \code{chance_level}
    (typically with \code{chance_level = 0}).
  \item If \code{predictor_id = NA}, the function tests whether the outcome differs
    from \code{chance_level} over time (useful for decoding accuracies,
    for instance).
}}

\item{trials_id}{Character; name of the column in \code{data}
containing the number of trials when using \code{family = binomial()}
and summary data. If NULL (default), the function internally summarise binary
data into "successes" and total number of "trials".}

\item{family}{A \pkg{brms} family object describing the response
distribution to be used in the model (defaults to \code{gaussian()}).}

\item{kvalue}{Numeric; basis dimension \code{k} passed to the smooth term
\code{s(time, ..., k = kvalue)}.}

\item{bs}{Character; Character scalar; type of spline basis to be used by \pkg{brms}
(passed to \code{s()}, e.g., \code{"tp"} for thin-plate splines).}

\item{multilevel}{Character; which model to fit. One of
\itemize{
  \item \code{"summary"}: GAMM fitted to participant-level summary
    statistics (mean outcome and its standard deviation);
  \item \code{"group"}: Group-level GAM fitted to participant-averaged
    data (no random/varying effects).
}}

\item{include_ar_term}{Logical; if \code{TRUE}, adds an AR(1) autocorrelation
structure within participant via
\code{autocor = brms::ar(time = "time", gr = "participant", p = 1, cov = FALSE)}.
Note that this is usually not necessary when using multilevel = "summary".}

\item{participant_clusters}{Logical; should we return clusters at the participant-level.}

\item{varying_smooth}{Logical; should we include a varying smooth. Default is
TRUE. If FALSE, we only include a varying intercept and slope.}

\item{warmup}{Numeric; number of warm-up iterations per chain.}

\item{iter}{Numeric; total number of iterations per chain (including warmup).}

\item{chains}{Numeric; number of MCMCs.}

\item{cores}{Numeric; number of parallel cores to use.}

\item{backend}{Character; package to use as the backend for fitting the
Stan model. One of \code{"cmdstanr"} (default) or \code{"rstan"}.}

\item{stan_control}{List; parameters to control the MCMC behaviour, using
default parameters when NULL. See \code{?brm} for more details.}

\item{n_post_samples}{Numeric; number of posterior draws used to compute
posterior probabilities. If \code{NULL} (default), all available draws
from the fitted model are used.}

\item{threshold}{Numeric; threshold on the posterior odds used to define
contiguous temporal clusters. Values greater than 1 favour the hypothesis
that the effect exceeds \code{chance_level}.}

\item{threshold_type}{Character scalar controlling which clusters are
detected. Must be one of \code{"above"}, \code{"below"}, or \code{"both"}
(default). When \code{"above"}, clusters are formed where
\code{value >= threshold}. When \code{"below"}, clusters are formed where
\code{value <= 1/threshold}. When \code{"both"}, both types are detected
and the returned data include a \code{sign} column.}

\item{chance_level}{Numeric; null value for the outcome (e.g., 0.5 for
decoding accuracy).}

\item{credible_interval}{Numeric; width of the credible (quantile) interval.}
}
\value{
An object of class \code{"clusters_results"}, which is a list with
  elements:
  \itemize{
    \item \code{clusters}: a data frame with one row per detected cluster
      (e.g., \code{cluster_onset}, \code{cluster_offset}, \code{duration});
    \item \code{predictions}: a data frame with time-resolved posterior
      summaries (posterior median, credible interval, posterior
      probabilities, and odds \code{prob_ratio});
    \item \code{data}: data used to fit the \pkg{brms} model
      (possibly summarised);
    \item \code{model}: the fitted \pkg{brms} model object;
    \item \code{multilevel}: the value of the \code{multilevel} argument.
  }

  The object has an associated \code{plot()} method for visualising the
  smoothed time course and detected clusters, as well as \code{print()} and
  \code{summary()} methods.
}
\description{
Fits time-resolved Bayesian generalised additive (multilevel) models (BGAMMs)
using \pkg{brms}, and computes posterior odds for an effect at each time
point. The effect can be either i) a deviation of the outcome from a
reference value (e.g., zero or a chance level), or ii) a difference between two
groups/conditions.
}
\details{
Internally, the function:
\enumerate{
  \item builds a formula with a smooth term over time (optionally by group);
  \item fits a \pkg{brms} model according to \code{multilevel};
  \item uses \pkg{tidybayes} to extract posterior predictions over time;
  \item computes, at each time point, the posterior probability that the
    effect (or condition difference) exceeds \code{chance_level};
  \item converts this into posterior odds (\code{prob_ratio}) and applies
    a clustering procedure (\code{find_clusters()}) over time.
}
}
\examples{
\dontrun{
# import some simulated EEG data
data(eeg_data)
head(eeg_data)

# fit the BGAMM to identify clusters
results <- testing_through_time(data = eeg_data)

# display the identified clusters
summary(results)

# plot the model predictions and identified clusters
plot(results)
}

}
\seealso{
\code{\link[brms]{brm}}
}
\author{
Ladislas Nalborczyk \email{ladislas.nalborczyk@cnrs.fr}.
}
